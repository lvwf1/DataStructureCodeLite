// Working set dynamic replacement algorithm
// The page reference stream is generated
// Using a Normal distribution.
// J. Garrido - Jan 2002
//  Rev for Psim3, Feb 2004
//

#include "proc.h"
using namespace std;
//
class wsa;
class gen_pgrefs;

// Globals
//
const int WS_WINDOW = 15;     // zize of Working Set Window
const int NUM_PAGES = 300;    // size of page reference stream
const int PROG_SIZE = 40;     // size of program in pages
//
long simperiod = 100;         // simulation period

int prstream[NUM_PAGES];      // page reference stream
//
int list_page[WS_WINDOW];     // list of pages in memory
//
//
gen_pgrefs *pgens;    // object to generate page references
wsa *WSalg;           // object for Working Set page replacement
simulation *run;      // simulation object
//
int m_loc, m_i;       // indeces for maniplating arrays
//
// Process Specifications
//
// The page reference stream is generated by process 'gen_pgrefs'
// using a normal probability distribution
// An instance of this class is a passive object, instantiated from 'main'
//
//
class gen_pgrefs {
   // Normal random number generator
   long mean_pag;                  // mean page
   long std;                       // standard deviation for pages
   float cv;                       // coefficient of variance
   normal *nselect_pg;
public:
   gen_pgrefs(char *rname, long meanpg, float cvariance);
   void generate(void);
};
//
// Working Set Alg. (Variant of LRU)
class wsa : public process {
  int mpage;             // number of pages in memory
  int num_pagws;         // number pages in last window
  int j;                 // index of current ref page in ref stream
  int num_faults;        // number of page faults
  int ref_page;          // page being referenced
public:
  wsa (char *sname);
  void Main_body(void);
  void pages_ws(void);   // get the number of pages in last window
};
//
// Implementations
//       Generate page reference stream
gen_pgrefs::gen_pgrefs(char *rname, long meanpg, float variance) {
   // Normal distribution with coef. of variance, cv
   cv = variance;
   mean_pag = meanpg;
   std = long(float(mean_pag) * cv);
   cout << "Constructor generator, cvar: " << cv << " " << mean_pag
        << " " << std << endl;
   nselect_pg = new normal(mean_pag, std);
}
//
void gen_pgrefs::generate(void) {
   int page;
   for (int jj = 0; jj < NUM_PAGES; jj++) {
         // cout << "Draw from Normal" << endl;
         page = (int)nselect_pg->draw();
         // discard pages out of range of the program
         while (page <= 0 || page > PROG_SIZE) {
            page = (int)nselect_pg->draw();
            // cout << "non-useful page: " << page << endl;
         }
         prstream[jj] = page;
         // cout << prstream[jj] << " " << jj << " ";
   }
   // cout << endl;
}
//
//
// Working Set Algorithm
// Estimate the size of the locality of the process
// by determining its working set
// Replace the page in memory that has not been used for the
// longest period (of time)
//
wsa::wsa(char *s) : process(s) {
  mpage = 0;        // current number of pages in memory
  j = 0;
  num_faults = 0;   // cur number of page faults
  // cout << "Creating " << t_name << endl;
}
//
void wsa::Main_body(void) {
 // Least Recently Used (wsa) Algorithm with dynamic replacement
 bool found = false;
 int num_rem;               // number of frames to deallocate
 while (j < NUM_PAGES) {
   // Get the next page referened in the page reference stream
   ref_page = prstream[j];
   // cout << endl; 
   cout << "Page referenced: " << ref_page << endl;          
   //
   // Determine if page referenced is in memory
   //
   found = false;
   m_i = 0;                  // index of first page
   cout << "Number of pages in mem: " << mpage << endl;   cout << "List of pages in mem: ";
   // Determine if referenced page is in memory
   if (mpage == 0)
      found = false;
   else {
     // display pages in memory
     while ( m_i < mpage) {
       cout << list_page[m_i] << " ";
       m_i++;

     }
     cout << endl;
     m_i = 0;
     while (m_i < mpage &&  found == false) {
       // cout << "Comparing page: " << list_page[m_i] << endl;
       if( list_page[m_i] == ref_page)
          found = true;
       else
          m_i++;                         // compare next page
     }
   }
   if (m_i == mpage && m_i > 0)
       m_i--;
   // cout << endl;
   //
   // found indicates whether page is in memory
   // if page is in memory remove it, so it can be repositioned at the
   // top in the list

   if (found == true ) {
      // remove page being referenced
      // cout << "Reposition page: " << list_page[m_i] << endl;
      // erase element m_i from list (close gap)
      if (m_i > 0) {
        for (int ii = m_i; ii > 0; ii--)
          list_page[ii] = list_page[ii - 1];
        // mow insert new page at the top of list
        list_page[0] = ref_page;
      }
   }
   else {
      // if page not in memory, a page fault occurs
      // if there are no free frames, the last page is removed
      //
      num_faults++;             // page fault
      cout << "Page fault, accum pg faults: " << num_faults << endl;
      if (mpage < WS_WINDOW)     // frames available?

         mpage++;
      if (mpage > 0) {
         // shift down all pages, remove the bottom page
         for (int ii = mpage-1; ii > 0; ii--) {
             list_page[ii] = list_page[ii-1];
         }
      }

      list_page[0] = ref_page;
      // cout << "Page inserted at the top of list" << endl;
   }
   //
   // Determine the number of different pages in the last window
   pages_ws();  // get number of different pages in last window
   //
   cout << "Frame allocation after ref page " << ref_page << " is: "
        << num_pagws << " frames" << endl;
   //

   // if number of different pages in window is less than
   // current number of frames allocated
   // remove the appropriate number of pages
   if (num_pagws < mpage && j >= WS_WINDOW) {
     num_rem = mpage - num_pagws;    // numb frames to deallocate
     mpage -= num_rem;               // decrease pages in memory
     cout << "Decreasing frame allocation by " << num_rem << endl;
   }
   //
   // if number of different pages in window is greater than
   // current number of frames allocated
   // increase the appropriate number of pages

   if (num_pagws > mpage && j >= WS_WINDOW) {
     num_rem = num_pagws - mpage;    // numb frames to allocate
     mpage += num_rem;               // increase pages in memory
     cout << "Increasing frame allocation by " << num_rem << endl;
   }

   j++;
 }    // end while for all pages in page reference stream
 cout << endl;
 cout << "Total number of page faults: " << num_faults << endl;
 cout << "Total number of page references: " << NUM_PAGES << endl;
 cout << "Proportion of pg faults to pg refs.: "
      << float(num_faults)/float(NUM_PAGES) << endl;
 cout << endl;
 terminate();
} // wsa Main_body
//
//
// Calculate the number of different pages in last window
void wsa::pages_ws(void) {
  //
  bool found;
  int jj;
  int i;
  int npagew = 0;
  int win_page [WS_WINDOW];  // last window array
  if (j < (WS_WINDOW - 1))   // window not complete yet
    num_pagws = mpage;       // number of pages in memory
  else {
    i = j - (WS_WINDOW - 1); // index at which to start counting
    // cout << "Starting index of WS window: " << i << " j = " << j << endl;
    // cin >> ans;
    for (int k = i; k <= j; k++) {
      // is page k in win_page ?
      found = false;
      jj = 0;
      if (npagew > 0) {
         while (found == false && jj < npagew) {
            if (win_page[jj] == prstream[k])
                found = true;
            else
                jj++;
         }
         // add page to window
         if (found == false) {
            win_page[jj] = prstream[k];
            npagew++;

         }
      }  // if npagew
      else {
         win_page[jj] = prstream[k];
         npagew++;
      }
    }   // for int k ...
    num_pagws = npagew;
  } // else WS_WINDOW
}

// -------------------------------------------------------------
//
   class pgreplace : public process {
   public:
      pgreplace(char *s);
      void Main_body(void);
   };
//
   pgreplace::pgreplace (char *s) : process(s) {
      // cout << s << " created" << endl;
   }
//
   void pgreplace::Main_body(void) {
      // cout << "Main_body of " << t_name << endl;
      // generate the page stream randomly
      // with Normal prob distribution
      pgens->generate();
      //
      WSalg = new wsa("Working Set");
      WSalg->pstart();
      //
      run->start_sim(simperiod);
   }
//

int main () {
   //
   long mean_pg = 20;                  // mean page
   float cvar = 0.55f;                 // coefficient of variance
   pgreplace *prep_model;
   run = new simulation("Working Set Algorithm");
   pgens = new gen_pgrefs("Generate page stream", mean_pg, cvar);
   //
   // control thread
   prep_model = new pgreplace("Control thread WS Pg Rep");
   prep_model->pstart();
   //
   run->end_sim();
   return 0;
   //
}
